## Description

Assignment API - A NestJS application with secure user authentication using JWT, PostgreSQL database, and Swagger documentation.

## Prerequisites

- Node.js (v18 or higher)
- PostgreSQL (via Postgres.app recommended for macOS)
- npm or yarn

## Project Setup

### 1. Install Dependencies

```bash
$ npm install
```

### 2. PostgreSQL Setup

#### Option A: Using Postgres.app (Recommended for macOS)

1. **Download and Install Postgres.app**
   - Download from: https://postgresapp.com/
   - Install by dragging to Applications folder
   - Launch Postgres.app
   - Click "Initialize" to create a new PostgreSQL server

2. **Add Postgres.app to PATH**

   ```bash
   echo 'export PATH="/Applications/Postgres.app/Contents/Versions/latest/bin:$PATH"' >> ~/.zshrc
   source ~/.zshrc
   ```

3. **Create Database and User**

   ```bash
   # Connect to PostgreSQL (use your macOS username or create postgres user)
   psql -h localhost -U postgres postgres
   # Or if postgres user doesn't exist, connect with your macOS username first
   ```

   Then run these SQL commands:

   ```sql
   -- Create postgres user (if it doesn't exist)
   CREATE USER postgres WITH SUPERUSER PASSWORD 'postgres';

   -- Create the database
   CREATE DATABASE assignment_db;

   -- Grant privileges
   GRANT ALL PRIVILEGES ON DATABASE assignment_db TO postgres;

   -- Connect to the database
   \c assignment_db

   -- Grant schema privileges
   GRANT ALL ON SCHEMA public TO postgres;

   -- Exit
   \q
   ```

#### Option B: Using Homebrew

```bash
# Install PostgreSQL
brew install postgresql@15

# Start PostgreSQL service
brew services start postgresql@15

# Create database
createdb assignment_db

# Create user
psql postgres -c "CREATE USER postgres WITH SUPERUSER PASSWORD 'postgres';"
```

### 3. Environment Variables

Create a `.env` file in the root directory:

```env
# Server Configuration
PORT=3000

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=postgres
DB_NAME=assignment_db

# JWT Configuration
JWT_SECRET=your-secret-key-change-in-production

# Frontend URL (for CORS)
FRONTEND_URL=http://localhost:3000

# OpenAI API Configuration (for transcription)
# Use either OPEN_AI_KEY or OPENAI_API_KEY
OPEN_AI_KEY=your-openai-api-key-here
# Optional: OpenAI API base URL (defaults to https://api.openai.com/v1)
# OPENAI_API_BASE_URL=https://api.openai.com/v1

# Environment
NODE_ENV=development
```

**Important:** Change `JWT_SECRET` to a secure random string in production!

### 4. Start the Application

```bash
# development
$ npm run start:dev
```

The application will:

- Connect to PostgreSQL
- Automatically create database tables from entities (in development mode)
- Start on http://localhost:3000
- Swagger documentation available at http://localhost:3000/api

## API Endpoints

### Authentication

- `POST /auth/register` - Register a new user
  - Body: `{ email, password, firstName?, lastName? }`
  - Returns: `{ access_token, user }`

- `POST /auth/login` - Login user
  - Body: `{ email, password }`
  - Returns: `{ access_token, user }`

### User Management (Protected - requires JWT token)

- `GET /users/profile` - Get current user profile
  - Headers: `Authorization: Bearer <token>`
  - Returns: User profile information

### Interview Generation (Protected - requires JWT token)

- `POST /interviews/generate` - Generate technical interview questions
  - Headers: `Authorization: Bearer <token>`
  - Body:
    ```json
    {
      "skills": ["JavaScript", "React", "Node.js"],
      "questionsPerSkill": 3,
      "difficulty": "intermediate",
      "context": "Focus on best practices"
    }
    ```
  - Returns: Generated interview questions with skill, question, difficulty, and category

- `GET /interviews` - Get all interviews for the authenticated user
  - Headers: `Authorization: Bearer <token>`
  - Returns: List of all interviews generated by the user

- `GET /interviews/:id` - Get a specific interview by ID
  - Headers: `Authorization: Bearer <token>`
  - Returns: Interview details with questions

### Interview Sessions (Protected - requires JWT token)

- `POST /interviews/:interviewId/start` - Start a new interview session
  - Headers: `Authorization: Bearer <token>`
  - Returns: Session details and first question

- `GET /interviews/sessions` - Get all interview sessions for the user
  - Headers: `Authorization: Bearer <token>`
  - Returns: List of all interview sessions

- `GET /interviews/sessions/:sessionId` - Get session details
  - Headers: `Authorization: Bearer <token>`
  - Returns: Session with answers and evaluations (if completed)

- `GET /interviews/sessions/:sessionId/answers` - Get all answers for a session
  - Headers: `Authorization: Bearer <token>`
  - Returns: List of answers with evaluations

- `POST /interviews/sessions/:sessionId/complete` - Complete interview and get evaluations
  - Headers: `Authorization: Bearer <token>`
  - Returns: Complete evaluation results with scores and feedback

### WebSocket - Live Transcription

- **WebSocket Endpoint**: `ws://localhost:3000/transcription`
- **Authentication**: JWT token required (sent in connection handshake)
- **Namespace**: `/transcription`

#### Connection

Connect to the WebSocket with JWT token in one of these ways:

- Query parameter: `ws://localhost:3000/transcription?token=<jwt_token>`
- Auth header: `Authorization: Bearer <jwt_token>` (in handshake)
- Auth object: `{ auth: { token: '<jwt_token>' } }` (in handshake)

#### Events

**Client → Server:**

- `start-transcription` - Start a new transcription session
  - Body: `{ sessionId?: string }` (optional, auto-generated if not provided)
  - Response: `transcription-started` event with `{ sessionId, message }`

- `audio-chunk` - Send audio data chunk
  - Body: `{ audio: string, sessionId?: string, isFinal?: boolean }`
    - `audio`: Base64 encoded audio data
    - `sessionId`: Session identifier (optional)
    - `isFinal`: Whether this is the final chunk (optional)
  - Response: `transcription-result` event with transcription text

- `stop-transcription` - Stop an active transcription session
  - Body: `{ sessionId: string }`
  - Response: `transcription-stopped` event

**Server → Client:**

- `connected` - Connection established
  - Data: `{ message: string, userId: string }`

- `transcription-started` - Transcription session started
  - Data: `{ sessionId: string, message: string }`

- `transcription-result` - Transcription result (partial or final)
  - Data: `{ sessionId: string, text: string, isPartial: boolean, timestamp: string }`

- `transcription-complete` - Transcription session completed
  - Data: `{ sessionId: string, message: string }`

- `transcription-stopped` - Transcription session stopped
  - Data: `{ sessionId: string, message: string }`

- `transcription-error` - Error occurred during transcription
  - Data: `{ sessionId: string, error: string }`

### WebSocket - Interview Flow

- **WebSocket Endpoint**: `ws://localhost:3000/interview`
- **Authentication**: JWT token required (sent in connection handshake)
- **Namespace**: `/interview`

#### Connection

Connect to the WebSocket with JWT token in one of these ways:

- Query parameter: `ws://localhost:3000/interview?token=<jwt_token>`
- Auth header: `Authorization: Bearer <jwt_token>` (in handshake)
- Auth object: `{ auth: { token: '<jwt_token>' } }` (in handshake)

#### Events

**Client → Server:**

- `start-interview` - Start a new interview session
  - Body: `{ interviewId: string }`
  - Response: `question-ready` event with first question and TTS audio

- `get-question` - Get current question
  - Body: `{ sessionId: string }`
  - Response: `question-ready` event with question and TTS audio

- `submit-answer` - Submit answer transcription
  - Body: `{ sessionId: string, questionIndex: number, transcription: string }`
  - Response: `answer-received` event

- `next-question` - Move to next question
  - Body: `{ sessionId: string }`
  - Response: `question-ready` event or `no-more-questions` if complete

- `complete-interview` - Complete interview and trigger batch evaluation
  - Body: `{ sessionId: string }`
  - Response: `interview-complete` event with all evaluations

- `get-session-status` - Get current session state
  - Body: `{ sessionId: string }`
  - Response: `session-status` event

**Server → Client:**

- `connected` - Connection established
  - Data: `{ message: string, userId: string }`

- `question-ready` - Question with TTS audio ready
  - Data: `{ sessionId: string, questionIndex: number, questionText: string, audioBase64: string | null, questionNumber: number, totalQuestions: number }`

- `answer-received` - Answer stored successfully
  - Data: `{ sessionId: string, questionIndex: number, message: string }`

- `no-more-questions` - All questions answered
  - Data: `{ sessionId: string, message: string }`

- `interview-complete` - Interview completed with evaluations
  - Data: `{ sessionId: string, evaluations: Array, overallScore: number, summary: string, recommendations: string[] }`

- `session-status` - Current session state
  - Data: `{ sessionId: string, status: string, currentQuestionIndex: number, startedAt: Date, completedAt: Date, answersCount: number }`

- `error` - Error occurred
  - Data: `{ message: string, code?: string }`

### API Documentation

Swagger UI is available at: http://localhost:3000/api

## Running the Project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Features

- ✅ Secure user authentication with JWT
- ✅ Password hashing at entity level using bcrypt
- ✅ PostgreSQL database with TypeORM
- ✅ Swagger API documentation
- ✅ Input validation with class-validator
- ✅ CORS enabled
- ✅ Protected routes with JWT guards
- ✅ WebSocket support for real-time transcription
- ✅ JWT authentication for WebSocket connections
- ✅ AI-powered interview question generation using OpenAI
- ✅ Interview session management with answer storage
- ✅ Batch answer evaluation with AI (scores and detailed feedback)
- ✅ Text-to-speech for questions via WebSocket
- ✅ Complete interview flow with WebSocket events

## Database

The application uses PostgreSQL with TypeORM. In development mode, tables are automatically created from entities (`synchronize: true`).

**⚠️ Important:** Set `synchronize: false` in production and use migrations instead!

## Security

- Passwords are automatically hashed using bcrypt (10 salt rounds) at the entity level
- JWT tokens expire after 24 hours
- All endpoints are validated using class-validator
- Protected routes require valid JWT Bearer token

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```
